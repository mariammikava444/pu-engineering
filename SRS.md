# Software Requirements Specification (SRS)
___
 "მოთხოვნების აქტივობის" (requirements activity) მიზანია პროგრამული უზრუნველყოფის მოთხოვნების სპეციფიკაციის (SRS) წარმოება. 

ყოველ პროგრამულ სისტემას სამი დაინტერესებული წევრი ჰყავს:
- **კლიენტი** - რომელსაც ამ სისტემის აწყობა სურს.
- **დეველოპერი** - რომელიც ამ სისტამს ააწყობს.
- **მომხმარებლები** - რომლებიც ამ სისტემას გამოიყენებენ.

SRS-ის ძირითადი მიზანია გადალახოს კლიენტისა და დეველოპერის კომუნიკაციის უფსკრული, რათა მათ ჰქონდეთ საერთო ხედვა პროგრამული უზრუნველყოფის განვითარების შესახებ.

**(SRS) ათანხმებდეს კლიენტსა და მომწოდებელს შორის იმას, თუ რას გააკეთებს პროგრამული პროდუქტი.** ***SRS გვაძლევს საბოლოო პროდუქტის ვალიდაციის მექანიზმს.***

**მაღალი ხარისხის SRS არის წინაპირობა მაღალი ხარისხის პროგრამული უზრუნველყოფისა.** ***მაღალი ხარისხის SRS ამცირებს განვითარების ღირებულებას.***

# მოთხოვნების დადგენის პროცესი
___
მოთხოვნის დადგენის პროცესი არის აქტივობების თანმიმდევრობა, რომელიც **უნდა შესრულდეს მოთხოვნების ფაზაში** და რომელიც **მთავრდება SRS-ის შემცველი მაღალი ხარისხის დოკუმენტის შექმნით.**

იგი შედგება სამი ძირითადი დავალებისაგან:
- ამოცანის ან მოთხოვნის ანალიზი
- მოთხოვნების სპეციფიკაცია
- მოთხოვნების ვალიდაცია

___
### ამოცანის ანალიზი
ხშირად იწყება მაღალი დონის "ამოცანის აღწერილობით".
ანალიზის დროს ხდება პრობლემის დომენის და გარემოს მოდელირება, რათა გავიგოთ სისტემის ქცევა, სისტემაში შეზღუდვები, მისი input-ები, output-ები და ა.შ.
ანალიტიკოსს ხშირად აქვს შეხვედრების სერია კლიენტებთან და საბოლოო მომხმარებელთან.
ადრეულ შეხვედრებზე კლიენტები და მომხმარებლები ანალიტიკოსს ესაუბრებიან თავიანთ სამუშაოზე, გარემოზე და საჭიროებებზე. ანალიტიკოსს შეიძლება ასევე გადაეცეს ნებისმიერი დოკუმენტი, რომელიც აღწერს სამუშაოს ან ორგანიზაციას. **ანალიტიკოსი ძირითადად მსმენელია და შთანთქავს მოწოდებულ ინფორმაციას.**
მას შეუძლია ინფორმაცია დოკუმენტის სახით გააფორმოს ან შექმნას რაღაც მოდელები, "იბრეინშტორმინგოს" ან იფიქროს იმაზე, თუ რა უნდა გააკეთოს სისტემამ. ბოლო რამდენიმე შეხვედრის დროს ანალიტიკოსი არსებითად უხსნის კლიენტს, თუ თავად როგორ ესმის სისტემის მუშაობა. იგი აზუსტებს - რასაც სისტემას სთავაზობს ნამდვილად შეესაბამება კლიენტების მიზნებს თუ არა.
### მოთხოვნების სპეციფიკაცია
ამოცანის ანალიზით მიღებული ცოდნა ქმნის მოთხოვნების სპეციფიკაციის საფუძველს, რომელშიც ყურადღება გამახვილებულია დოკუმენტში მოთხოვნების ***ნათლად დაზუსტებაზე***.
### მოთხოვნების ვალიდაცია
ვალიდაციის დროს მოწმდება, რომ რაც მითითებულია SRS-შ ნამდვილად შეესაბამება პროგრამული უზრუნველყოფის ყველა ოტხოვნას და SRS-იც არის კარგი ხარისხის.
___
**მოთხოვნების დადგენის პროცესი** არ არის ამ 3 აქტივობით აგებული წრფივი პროცესი და აქტივობებს შორის არის თანაკვეთა და უკუკავშირი.

# მოთხოვნების სპეციფიკაცია 2
___
კარგ SRS-ს სჭირდება ბევრი ისეთი რამის დაზუსტება, რაც არ დამუშავდა ანალიზის დროს. **არსებითად, რაც გადადის მოთხოვნების ანალიზის აქტივობიდან სპეციფიკაციის აქტივობაზე, არის სისტემის შესახებ მიღებული ცოდნა**.
SRS იწერება ანალიზის დროს მიღებული ცოდნის საფუძველზე. ამ ცოდნის სტრუქტურირებულ დოკუმენტად გადაქცევა არ არის მარტივი ამოცანა. სპეციფიკაციის აწყობა ცალკე, დამოუკიდებელ და დიდ ამოცანას წარმოადგენს.

# SRS-ის სასურველი მახასიათებლები
___
SRS-ის ზოგიერთი სასურველი მახასიათებლებია:
- Correct
- Complete
- Unambiguous
- Verifiable
- Consistent
- Ranked for importance

### Correct
SRS სწორია თუ მასში შეტანილი ყველა მოთხოვნა აღწერს ისეთ რამეს რაც საბოლოო სისტემისთვისაა საჭირო.
### Complete
ის სრულია, თუ ყველაფერი რაც პროგრამამ უნდა გააკეთოს და ყველა პასუხი ყველა შემავალ მონაცემზე მითითებულია SRS-ში.
### Unambiguous
იგი ცალსახაა მხოლოდ იმ შემთხვევაში, თუ ყველა მითითებულ მოთხოვნას აქვს ერთი და მხოლოდ ერთი ინტერპრეტაცია. მოთხოვნება ხშირად იწერება ბუნებრივ ენაზე, რაც თავისებურად ორაზროვანია. ამიტომაც თუ წერენ ბუნებრივ ენაზე, SRS-ის დამწერი უნდა იყოს ფრთხილად რომ არ იყოს მოთხოვნა გაურკვეველი.
### Verifiable
იგი გადამოწმებადია მხოლოდ იმ შემთხვევაში, თუ ყველა მითითებული მოთხოვნა თავად არის გადამოწმებადი. იგი გადამოწმებადია, თუ არსებობს რაიმე ნაკლებად ხარჯიანი პროცესი, რომელსაც შეუძლია შეამოწმოს, აკმაყოფილებს თუ არა ამ მოთხოვნას საბოლოო პროგრამული უზრუნვეყლოფა.
### Consistent
იგი შესაბამისობაშია, თუ არ არსებობს მოთხოვნა, რომელიც ეწინააღმდეგება სხვას.

**SRS ფასდება მნიშვნელობისა და/ან სტაბილურობის მიხედვით, თუ თითოეული მოთხოვნისთვის მითითებულია მოთხოვნის მნიშვნელობა და სტაბილურობა.**

**მოთხოვნის სტაბილურობა** ასახავს მომავალში მისი შეცვლის შანსებს. სტაბილურობა შეიძლება აისახოს მოსალოდნელი ცვლილების მოცულობით.
თითოეული **მოთხოვნის ღირებულების** განსაზღვრა აუცილებელი რამ არის იტერაციული განვითარების პროცესისთვის - მოთხოვნების შერჩევა ხდება ამ მაჩვენებლის მიხედვით.
# სპეციფიკაციის კომპონენტები
___
საკითხები რომელსაც SRS-მა ხაზი უნდა გაუსვას არის:
- Functionality
- Performance
- Design constraints imposed on an implementation
- External interfaces

## Functionality
ფუნქციონალური მოთხოვნებები განსაზღვრავს სისტემის მოსალოდნელ ქცევას: **რა output-ები უნდა მივიღოთ კონკრეტული input-ების დროს.**
სპეციფიკაციის მნიშვნელოვანი ნაწილია სისტემის ქცევა არასტანდარტულ, გამონაკლის სიტუაციებში. მაგალითად, არავალიდური input-ის ან გამოთვლის დროს მიღებული შეცდომის შემთხვევაში რა უნდა ქნას სისტემამ. 
## Performance
არსებობს ორი სახის წარმადობის მოთხოვნები:
- **სტატიკური** - განსაზღვრავს ისეთ შეზღუდვებს რომლებიც ზეგავლენას არ ახდეს აპლიკაციის შესრულების (execution) მახასიათებელზე.
- **დინამიური** - განსაზღვრავს ისეთ შეზღუდვებს, რომლებიც ზეგავლენას ახდენს აპლიკაციის შესრულების მახასიათებელზე.

**მოთხოვნები წარმადობაზე** უნდა იყოს მითითებული გაზომვად ტერმინებში.
მოთხოვნები, როგორიცაა *„პასუხის დრო (response time) კარგი უნდა იყოს“* ან სისტემას უნდა შეეძლოს *„ყველა ტრანზაქციის სწრაფად დამუშავება“* არ არის სასურველი, რადგან ისინი არაზუსტია და არ არის გადამოწმებადი.
## Design constraints imposed on an implementation
კლიენტის გარემოში არსებობს მრავალი ფაქტორი, რამაც შეიძლება შეზღუდოს დიზაინერის არჩევანი, რაც იწვევს დიზაინის შეზღუდვებს (design constraints).
ასეთი ფაქტორები მოიცავს, მაგალითად, *სტანდარტებს*, რომლებიც უნდა გავითვალისწინოთ, *რესურსების ლიმიტები*, *ოპერაციული სისტემა*, *საიმედოობისა* და *უსაფრთხოების მოთხოვნები* და *პოლიტიკები*, რომელსაც შეუძლია გავლენა მოახდინოს სისტემის დიზაინზე.

დიზაინის შეზღუდვების მაგალითები:
- **Standards Compliance**
- **Hardware Limitations**
- **Reliability and Fault Tolerance**
- **Security**

#### Standards Compliance
იგი განსაზღვრავს სტანდარტების მოთხოვნებს, რომლებიც სისტემამ უნდა გაითვალისწინოს. სტანდარტები შეიძლება მოიცავდეს ანგარიშის ფორმატს და აღრიცხვის პროცედურებს. შეიძლება არსებობდეს აუდიტის მოთხოვნები, რომლებიც შეიძლება მოითხოვდეს ლოგირებას (logging).
#### Hardware Compliance
პროგრამულ უზრუნველყოფას შეიძლება მოუწიოს იმუშაოს ზოგიერთ არსებულ ან წინასწარ განსაზღვრულ აპარატურაზე, რაც აწესებს შეზღუდვებს დიზაინზე.
#### Reliability and Fault Tolerance
შეცდომებისადმი ტოლერანტობის მოთხოვნებმა შეიძლება გამოიწვიოს მნიშვნელოვანი შეზღუდვები სისტემის დიზაინზე, რადგან ისინი სისტემას უფრო კომპლექსურს და ძვირად ღირებულს გახდის. ამ დროს ხშირია აღდგენის (recovery) მოთხოვნები, სადაც დეტალურად არის აღწერილი, თუ რა უნდა გააკეთოს სისტემამ, თუ მოხდება რაიმე სისტემური ჩავარდნა.
#### Security
უსაფრთხოების მოთხოვნები სულ უფრო მნიშვნელოვანი ხდება. ეს მოთხოვნები აწესებს შეზღუდვებს გარკვეული ბრძანებების გამოყენებაზე, აკონტროლებს მონაცემებზე წვდომას, უზრუნველყოფს სხვადასხვა სახის წვდომის მოთხოვნებს სხვადასხვა ადამიანებისთვის, მოითხოვს პაროლების და კრიპტოგრაფიის ტექნიკის გამოყენებას და სისტემაში აქტივობების ჟურნალის (activity log) შენარჩუნებას. 
# გარე ინტეფეისები
___
**გარე ინტერფეისის** სპეციფიკაციის ნაწილში, პროგრამული უზრუნველყოფის ყველა ინტერაქცია ადამიანებთან, აპარატურასა და სხვა პროგრამულ უზრუნველყოფასთან მკაფიოდ უნდა იყოს აღწერილი.
მომხმარებლის ინტერფეისისთვის (UI-სთვის) უნდა იყოს მითითებული პროგრამული პროდუქტის თითოეული ინტერფეისის მახასიათებლები. მომხმარებლის ინტერფეისი სულ უფრო მნიშვნელოვანი ხდება და მას სათანადო ყურადღება უნდა მიექცეს.
სხვა სპეციფიკაციების მსგავსად, ეს მოთხოვნები უნდა იყოს ზუსტი და შემოწმებადი. ასე რომ, თავიდან უნდა ავიცილოთ ისეთი წინადადება, როგორიცაა "სისტემა უნდა იყოს მომხმარებლისთვის მოსახერხებელი" და ჯობს გამოვიყენოთ წინადადება, როგორიცაა "ბრძანებები არ უნდა აღემატებოდეს ექვს სიმბოლოს" ან "ბრძანების სახელები უნდა ასახავდეს მათ მიერ შესრულებულ ფუნქციას".

**აპარატურული (hardware) ინტერფეისის მოთხოვნებისთვის**, SRS-ში უნდა იყოს მითითებული თითოეული ინტერფეისის ლოგიკური მახასიათებლები პროგრამულ პროდუქტსა და აპარატურულ კომპონენტებს შორის.

**SRS-ში უნდა გვეწეროს რას აკეთებს სისტემა და არა როგორ!**
